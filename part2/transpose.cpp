#include <iostream>

/*
 Конспект.

 - m[i] <=> *(m + i) - т.е. мы берем указатель m прибавляем к нему целое число i, далее * разименовывание т.е. берем значение.
 - В многомерном массиве есть массив с указателями на строки. То есть есть указать на указатель строки int **
 - * - это оператор разименования ссылки и получения ее значения

 const - (https://habr.com/ru/post/59558/) - создает переменную значение которой изменить нельзя

 size_t - базовый тип, размер которого соответствует размеру базавого типа операционный системы  64 32

 для более эффективного выделения памяти нужно:
 - выделить массив с указателями на строки
 - затем выделить массив со строками это будет площадь матрицы (rows * cols)
 - после этого поместить указатели на начало каждой строки в массив с указателми
 - т.е. отступаем от начала массива размер массива с указателями, плюс размер текущей строки умноженный на номер строки

*/
int **transpose(int **m, unsigned rows, unsigned cols) {
    int **m2 = new int *[cols];
    m2[0]= new int[rows * cols];
    for (int i = 1; i != cols; ++i) {
        m2[i] = m2[i - 1] + rows;
    }

    for (int i = 0; i != rows; ++i) {
        for (int j = 0; j != cols; ++j) {
            m2[j][i] = m[i][j];
        }
    }

    return m2;
}


int main() {
    int m2d[2][3] = {{1, 2, 3},
                     {1, 2, 3}};

    int rows = 3;
    int cols = 3;
    int **m = new int *[rows];
    int **m2 = new int *[rows];
    for (int k = 0; k < cols; ++k) {
        m2[k] = new int[rows];
    }

    for (size_t i = 0; i != rows; ++i) {
        m[i] = new int[4];
        for (size_t j = 0; j != cols; ++j) {
            m[i][j] = j;
        }
    }

    m2 = transpose(m, rows, cols);
    std::cout << m2[2][1] << m[1][2];
}